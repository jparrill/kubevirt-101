Kubevirt 101
Learn the new way to operate VMs
26 Sep 2019
Tags: Kubevirt, K8s, VMs

Juan Manuel Parrilla
Senior Software Engineer, Red Hat
jparrill@redhat.com
https://github.com/jparrill/kubevirt-101
@kerbeross

* About me

- Programming enthusiast
- Redhatter (~5 years)
- Openshift/Kubernetes Lover

.image img/avatar.jpg _ 250
.caption [[https://github.com/jparrill/kubevirt-101][Kubevirt 101]] by Juan Manuel Parrilla
.background img/background.png

* Index

- What is Kubevirt
- Briefly Pod/Containers basics
- Kubevirt Architecture
- Kubevirt Components
- Kubevirt Additional components
- Hands on Kubevirt

.background img/background.png


* Prologue
.background img/background.png

* What is kubevirt?

.image img/at_last_together.png _ 950
- _Virtual_Machine_management_addon_to_Kubernetes_that_extends_Kubernetes_in_a_way_that_allows_it_to_schedule_VM_workloads_side_by_side_with_container_workloads_.
.background img/background.png

* What is Kubevirt?

- Why do we do KubeVirt?
- Is there something wrong with RHV/oVirt?
- Is there something wrong with OpenStack/RDO?
.image img/question-img.png _ 550
.background img/background.png

* What is Kubevirt?

- Why do we do KubeVirt?
- Is there something wrong with RHV/oVirt?
- Is there something wrong with OpenStack/RDO?
.image img/question-img.png _ 250
*There*is*nothing*wrong*with*RHV/oVirt*or*Openstack,*What*we*try*to*solve*is*providing*a*unified*stack*for*hybrid*cloud*operations*based*on*OpenShift/Kubernetes.*
.background img/background.png

* Virtual Machines as just another Workload

** Some features of Kubevirt
- KubeVirt is managed by Operators
- KubeVirt is delivered via Pods, like any other k8s application.
- KubeVirt is fully integrated into k8s control plane.
- Normal kubectl/oc commands work with VMs too.
- [[https://github.com/kubernetes-sigs/krew-index/blob/master/plugins/virt.yaml][Krew add-on]] to interact with VMs.
.background img/background.png

* K8s Basics

** What are Containers?

Containers mostly use two isolation techniques provided by the kernel:

- cgroups
- namespaces
.image img/container.png _ 350
.background img/background.png

* K8s Basics

** What are Pods?
- Consists of one or more containers
- Each container has its own cgroups
- All containers of a pod share the network namespace

Each container has for the rest its own namespace:

- PID namespace
- IPC namespace
- Mount namespace

.background img/background.png


* K8s Basics
.image img/kubevirt_pod.png _ 750 
.background img/background.png

* Kubevirt Architecture
.background img/background.png

* Kubevirt Architecture
.image img/kubevirt_old_architecture_warning.png _ 700 
.background img/background.png

* Kubevirt Architecture
- What if we don’t fight the kubelet?
- What if we could simplify our lives by welcoming the fact that containers do a lot of security and isolation work for us?
.image img/question-img.png _ 550
.background img/background.png


* Kubevirt Architecture
How about starting one libvirt instance inside the container where the Virtual Machine is supposed to run in?
We don’t have to trick libvirt or Kubernetes then in any way:

- Kubernetes provides the resources
- Libvirt runs inside the target pod and sees what it is supposed to see and what it can use for defining the Virtual Machine
.background img/background.png

* Kubevirt Architecture
.image img/kubevirt_new_arch.png _ 550
- Libvirt runs inside a container!
.background img/background.png

* Kubevirt Components
.background img/background.png

* virt-api-server

HTTP API server which serves as the entry point for all virtualization related flows.

The API Server is taking care to update the virtualization related custom resource definition (see below).

As the main entrypoint to KubeVirt it is responsible for defaulting and validation of the provided VMI CRDs.

.background img/background.png

* virt-api-server
VMI definitions are kept as custom resource definitions inside the Kubernetes API server.

The VMI definition is defining all properties of the Virtual machine itself, like:

- Machine type
- CPU type
- Amount of RAM and vCPUs
- Number and type of NICs
- …

.background img/background.png


* virt-controller
From a high-level perspective the virt-controller has all the cluster wide virtualization functionality.

This controller is responsible for monitoring the VMI (CRDs) and managing the associated pods. Currently the controller will make sure to create and manage the life-cycle of the pods associated to the VMI objects.

A VMI object will always be associated to a pod during it's life-time, however, due to i.e. migration of a VMI the pod instance might change over time.

.background img/background.png


* virt-launcher
The main purpose of the virt-launcher Pod is to provide the cgroups and namespaces, which will be used to host the VMI process.

virt-handler signals virt-launcher to start a VMI by passing the VMI's CRD object to virt-launcher. virt-launcher then uses a local libvirtd instance within its container to start the VMI. From there virt-launcher monitors the VMI process and terminates once the VMI has exited.

.background img/background.png


* virt-handler
Every host needs a single instance of virt-handler. It can be delivered as a DaemonSet.

Like the virt-controller, the virt-handler is also reactive and is watching for changes of the VMI object, once detected it will perform all necessary operations to change a VMI to meet the required state.

- Keep a cluster-level VMI spec in sync with a corresponding libvirt domain.
- Report domain state and spec changes to the cluster.
- Invoke node-centric plugins which can fulfill networking and storage requirements defined in VMI specs.

.background img/background.png

* libvirtd
An instance of libvirtd is present in every VMI pod. virt-launcher uses libvirtd to manage the life-cycle of the VMI process.

.image img/libvirt-logo.png _ 650
.background img/background.png

* Kubevirt Folks
.background img/background.png

* CDI - Containerized Data Importer

Containerized-Data-Importer (CDI) is a persistent storage management add-on for Kubernetes

It's primary goal is to provide a declarative way to build Virtual Machine Disks on PVCs for Kubevirt VMs

- Get your life easier using CDI
- Works with standard core Kubernetes resources
- Has an operator to manage the deployment + life-cycle
- Storage device agnostic
- Builds disk images for Kubevirt
- Initializing your Kubernetes Volumes with data
.background img/background.png


* Multus

Multus is a _meta_ CNI (Container Network Interface) plugin for Kubernetes that enables attaching multiple network interfaces to pods.

- Allows multiple CNIs to coexist
- Allows for a pod to use the right cni plugin for its networking needs

.image img/multus-arch.png
.background img/background.png

* Hands on Kubevirt
.background img/background.png


* Hands on Kubevirt

Let's do some assumption:

- We have a K8s Cluster up and Running....ok if not just put this:
    GO111MODULE="on" go get sigs.k8s.io/kind@v0.5.1 && kind create cluster
    export KUBECONFIG="$(kind get kubeconfig-path --name="kind")"
- We have already a SC pre-defined on the cluster and as a default one, let put it as a non default in order to let _hostpath_provisioner_ to do this job:
	kubectl patch storageclass standard -p '{"metadata": {"annotations":{"storageclass.kubernetes.io/is-default-class":"false"}}}'
- Now it's time to install Kubevirt...
.background img/background.png


* Hands on Kubevirt
- Execute those commands in order to install Kubevirt
.code samples/install-kubevirt.sh
- Check how it's going...
	# kubectl get pods -n kubevirt
.image img/pods_kubevirt.png
.background img/background.png

* Hands on Kubevirt
Ok now we have Kubevirt installed and working.

- Let's install CDI
.code samples/install-cdi.sh
- Check how it's going...
	# kubectl get pods -n cdi
.background img/background.png

* Hands on Kubevirt
- This is how should looks like 
.image img/pods_cdi.png
Once both are installed we will create a PVC which will use CDI to import a cirros image into it:
.code -edit samples/use-cdi.sh /^# Import/,/cirros-pvc.yaml/ 
- This is how looks like the importation process:
.image img/pod_import.png
.background img/background.png

* Hands on Kubevirt
- And this is the importer pod's log:
.code samples/cdi_import.log
.background img/background.png


* Hands on Kubevirt
- Now we need to create the VM:
.code -edit samples/use-cdi.sh /^# Create/,/cirros-vm.yaml/ 
- And this is how looks like the VM process:
    NAME                            READY   STATUS    RESTARTS   AGE
    virt-launcher-vm-cirros-p68f5   0/1     Running   0          10s

- VM:
    NAME        AGE     RUNNING   VOLUME
    vm-cirros   3m38s   true      


- VMI:
    NAME        AGE     PHASE     IP            NODENAME
    vm-cirros   3m10s   Running   10.244.0.21   kind-control-plane

.background img/background.png

* Hands on Kubevirt
Testing Multus:

- Install OpenVSwitch on Kind:

    # sudo dnf install openvswitch -y
    # sudo systemctl enable --now openvswitch
.background img/background.png

